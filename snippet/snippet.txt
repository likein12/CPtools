{

	"BFS.py" : {
		"prefix" : "BFS"

		"body" : [
			,
						"from collections import deque"
,
						""
,
						"vi = 0  #change"
,
						"INF = float("inf")"
,
						""
,
						"Q = deque([vi])"
,
						""
,
						"checked_list = [False]*N"
,
						"checked_list[vi]=True"
,
						""
,
						"min_path_list = [INF]*N #change"
,
						"min_path_list[vi] = 0"
,
						""
,
						"while len(Q)>0:"
,
						"    v = Q.pop()"
,
						"    for v1 in e_list[v]:"
,
						"        if not checked_list[v1]:"
,
						"            checked_list[v1]=True"
,
						"            Q.appendleft(v1)"
,
						"            min_path_list[v1]=min(min_path_list[v1],min_path_list[v]+1) #change"
,
			
		]

		"description" : "conduct BFS"

	}

	"input.py" : {
		"prefix" : "inp"

		"body" : [
			,
						"list(map(int,input().split()))"
,
			
		]

		"description" : "input"

	}

	"dijkstra.py" : {
		"prefix" : "dijkstra"

		"body" : [
			,
						"#dijkstra"
,
						"#you need to prepare e_list = [(orient,dist)]"
,
						""
,
						"import heapq"
,
						""
,
						"vi = 0"
,
						"INF = float("inf")"
,
						"min_d_list = [INF]*N"
,
						"min_d_list[vi] = 0"
,
						"prev_list = [-1]*N"
,
						"q = []"
,
						"for i in range(N):"
,
						"	heapq.heappush(q,(min_d_list[i],i))"
,
						""
,
						"while len(q)>0:"
,
						"	d,v = heapq.heappop(q)"
,
						"	for e in e_list[v]:"
,
						"		v1,d1 = e"
,
						"		if min_d_list[v1] > d+d1:"
,
						"			min_d_list[v1] = d+d1"
,
						"			prev_list[v1] = v"
,
						"			heapq.heappush(q,(d+d1,v1))"
,
			
		]

		"description" : "conduct dijkstra"

	}

	"UnionFind.py" : {
		"prefix" : "UnionFind"

		"body" : [
			,
						"class UnionFind():"
,
						"    def __init__(self,size):"
,
						"        self.table = [-1 for _  in range(size)]"
,
						"        self.member_num = [1 for _ in range(size)]"
,
						" "
,
						"    #representative"
,
						"    def find(self,x):"
,
						"        while self.table[x] >= 0:"
,
						"            x = self.table[x]"
,
						"        return x"
,
						""
,
						"    def union(self,x,y):"
,
						"        s1 = self.find(x)"
,
						"        s2 = self.find(y)"
,
						"        m1=self.member_num[s1]"
,
						"        m2=self.member_num[s2]"
,
						"        if s1 != s2:"
,
						"            if m1 != m2:"
,
						"                if m1 < m2:"
,
						"                    self.table[s1] = s2"
,
						"                    self.member_num[s2]=m1+m2"
,
						"                    return [m1,m2]"
,
						"                else:"
,
						"                    self.table[s2] = s1"
,
						"                    self.member_num[s1]=m1+m2"
,
						"                    return [m1,m2]"
,
						"            else:"
,
						"                self.table[s1] = -1"
,
						"                self.table[s2] = s1"
,
						"                self.member_num[s1] = m1+m2"
,
						"                return [m1,m2]"
,
						"        return [0,0]"
,
			
		]

		"description" : "UF"

	}

	"BinaryIndexedTree.py" : {
		"prefix" : "BIT"

		"body" : [
			,
						"class BIT:"
,
						"            "
,
						"    def __init__(self, L):"
,
						"        self.N = len(L)"
,
						"        self.bit = [0]*self.N"
,
						"        for i,l in enumerate(L):"
,
						"            self.add(i,l)"
,
						""
,
						"    def add(self, a, w):"
,
						"        x = a + 1"
,
						"        for i in range(1000):"
,
						"            self.bit[x-1] += w"
,
						"            x += x & -x"
,
						"            if x > self.N:"
,
						"                break"
,
						""
,
						"    def sum(self, a):"
,
						"        x = a+1"
,
						"        ret = 0"
,
						"        for i in range(1000):"
,
						"            ret += self.bit[x-1]"
,
						"            x -= x & -x"
,
						"            if x <= 0:"
,
						"                break        "
,
						"        return ret"
,
						""
,
			
		]

		"description" : "BIT"

	}

	"SegmentTree.py" : {
		"prefix" : "SegmentTree"

		"body" : [
			,
						"class SegmentTree:"
,
						"    def __init__(self, L, op, ide):"
,
						"        self.op = op"
,
						"        self.ide = ide"
,
						"        self.sz = len(L)"
,
						"        self.n = 1"
,
						"        self.s = 1"
,
						"        for i in range(1000):"
,
						"            self.n *= 2"
,
						"            self.s += 1"
,
						"            if self.n >= self.sz:"
,
						"                break"
,
						"        self.node = [self.ide]*(2*self.n-1)"
,
						""
,
						"        for i in range(self.sz):"
,
						"            self.node[i+self.n-1] = L[i]"
,
						""
,
						"        for i in range(self.n-2,-1,-1):"
,
						"            self.node[i] = self.op(self.node[i*2+1],self.node[i*2+2])"
,
						"    "
,
						"    def add(self, a, x):"
,
						"        k = a+self.n-1"
,
						"        self.node[k] += x"
,
						"        for i in range(1000):"
,
						"            k = (k-1)//2"
,
						"            self.node[k] = self.op(self.node[2*k+1], self.node[2*k+2])"
,
						"            if k <= 0:"
,
						"                break"
,
						"    "
,
						"    def substitute(self, a, x):"
,
						"        k = a+self.n-1"
,
						"        self.node[k] = x"
,
						"        for i in range(1000):"
,
						"            k = (k-1)//2"
,
						"            self.node[k] = self.op(self.node[2*k+1], self.node[2*k+2])"
,
						"            if k <= 0:"
,
						"                break"
,
						""
,
						"    def get_one(self, a):"
,
						"        k = a+self.n-1"
,
						"        return self.node[k]"
,
						"    "
,
						"    def get(self, l, r):"
,
						"        res = self.ide"
,
						"        n = self.n"
,
						"        if self.sz <= r or 0 > l:"
,
						"            print("ERROR: the indice are wrong.")"
,
						"            return False"
,
						""
,
						"        for i in range(self.s):"
,
						"            count = 2**i-1"
,
						"            a = (r+1)//n"
,
						"            b = (l-1)//n"
,
						"            if a-b == 3:"
,
						"                res = self.op(self.node[count+b+1],res)"
,
						"                res = self.op(self.node[count+b+2],res)"
,
						"                right = a*n"
,
						"                left = (b+1)*n-1"
,
						"                break"
,
						"            if a-b == 2:"
,
						"                res = self.op(self.node[count+b+1],res)"
,
						"                right = a*n"
,
						"                left = (b+1)*n-1"
,
						"                break"
,
						"            n = n//2"
,
						""
,
						"        #left"
,
						"        n1 = n//2        "
,
						"        for j in range(i+1,self.s):"
,
						"            count = 2**j-1 "
,
						"            a = (left+1)//n1"
,
						"            b = (l-1)//n1"
,
						"            if a-b == 2:"
,
						"                res = self.op(self.node[count+b+1],res)"
,
						"                left = (b+1)*n1-1                "
,
						"            n1 = n1//2"
,
						""
,
						"        #right"
,
						"        n1 = n//2        "
,
						"        for j in range(i+1,self.s):"
,
						"            count = 2**j-1 "
,
						"            a = (r+1)//n1"
,
						"            b = (right-1)//n1"
,
						"            if a-b == 2:"
,
						"                res = self.op(self.node[count+b+1],res)"
,
						"                right = a*n1                "
,
						"            n1 = n1//2"
,
						"        return res"
,
						"    "
,
						"ST = SegmentTree(range(100000),lambda a,b:a+b,0)"
,
						"for i in range(10**5):"
,
						"    ST.add(i,1)"
,
			
		]

		"description" : "SegmentTree"

	}

}